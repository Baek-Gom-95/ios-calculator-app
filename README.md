## 목차

- [프로젝트 소개](#프로젝트-소개)
- [프로젝트 구조](#프로젝트-구조)
- [키워드](#키워드)
- [STEP 1](#step-1)
- [STEP 2](#step-2)
- [STEP 3](#step-3)

## 프로젝트 소개

## 프로젝트 구조(UML)

## 개발환경 및 라이브러리

[![swift](https://img.shields.io/badge/swift-5.0-orange)]()
[![xcode](https://img.shields.io/badge/Xcode-13.0-blue)]()

## 키워드
`TDD` `유니테스트` `프로토콜` `제네릭`

## [STEP 1]


### 고민한 점
- Queue 타입 구현에 있어 어떠한 방법으로 구현할까?
- Queue 타입에 들어올 데이터를 어떤 방법으로 제한할까?
### 배운 개념
- 시간 복잡도
- 자료구조(스택, 큐, 리스트)
- 제네릭
- TDD및 유니테스트
- 의존성 분리

#### 시간복잡도
시간복잡도엔
- O(1): 연산을 처리하는데 오직 한 단계만 거침.
- O(log n): 연산을 하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬.
- O(n): 연산단계의 수와 입력값 n이 1:1 관계를 가짐.
- O(n log n): 연산단계의 수가 N*(log2N) 번만큼의 수행시간을 가진다. (선형로그형)
- O(n^2): 연산단계의 수는 입력값 n의 제곱.
- O(C^n): 연산단계의 수는 주어진 상수값 C 의 n 제곱.
> [참고 블로그](https://blog.chulgil.me/algorithm/)

시간 복잡도는 특정 연산을 하는데 입력값에 의해 연산시간이 어떤식으로 영향을 받나를 표시하는 것

#### 자료구조(스택, 큐, 리스트)
- 스택: 선입후출=> 먼저 들어간 것이 가장 마지막에 나온다.
- 큐: 선입선출=> 먼저 들어간 것이 가장 먼저 나온다.
- 연결 리스트: 객체(노드)를 주소값을 이용하여 연쇄적으로 연결시켜 데이터를 관리하는 자료구조

#### 제네릭
타입 내부에서 사용되는 타입을 나중에 정한다.(인스턴스에서 넣어주거나 파라미터를 따름)
이번 프로젝트에서 제네릭을 이용한 이유는 [TIL-제네릭]()
> 큐 컬렉션에 들어올 타입을 미리 결정하지 않기 위해 사용했습니다.
swift에서 한 타입만을 결정하지 않고 타입을 사용하는 방법이 제네릭과 프로토콜로 결합도를 낮춰 프로토콜을 채택한 타입만을 받을 수 있는 방법 두 가지가 떠올랐고, 두 가지 방법 모두 사용해 보았습니다. 제네릭을 사용하면 인스턴스를 만들 때 타입이 정해져 그 인스턴스엔 정해진 타입만 담을 수 있고, 프로토콜을 사용하면, 채택한 타입은 모두 담을 수 있지만, 빈번한 다운 캐스팅을 해야 했고, 기존에 swift에 존재하는 컬렉션 타입 모두 제네릭을 사용하고 있는 점을 보았을 때, 제네릭을 사용하는 방법이 타당하다고 생각이 들었습니다. 때문에 프로토콜은 제네릭으로 들어올 수 있는 타입을 제약하는 방법으로 사용하였습니다.


#### TDD및 유니테스트
TDD는 개발 방법론 중 하나.
테스트를 거쳐가며, 기능을 구현하는 방법이다. TDD는 몇가지 절차를 반복하며, 기능을 구현하게 된다.
아래의 절차대로 진행
- 가장 먼저 테스트 코드를 작성한다.
- 테스트가 실패하도록 로직을 구현한다.(RED)
- 테스트가 성공하도옥 로직을 구현한다.(GREEN)
- 리펙토링(Refactor)

[TIL-TDD]()

유니테스트는 TDD에서 테스트 하는 방법 단위 테스트라고도 한다.
코드를 검증하는 절차이고, 메소드에 대한 테스트 케이스(Test case)를 작성하는 절차를 말한다.
[TIL-유니테스트]()

#### 의존성 분리
좋은 테스트를 위해선 의존성을 분리해줘야 한다.
의존성 분리는 솔리드 원칙에서 "의존관계 역전 원칙"을 이용한다. 때문에 프로토콜(인터페이스)이 사용되는데 결론부터 말하자면 프로토콜을 이용하여 추상 타입으로 프로토콜을 채택한 타입은 모두 받아들이는 방법이다.
[TIL-의존성 분리]()


